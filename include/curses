/*                                                                  -*- c++ -*-
 * Copyright Â© 2019 Ron R Wills <ron@digitalcombine.ca>
 *
 * This file is part of the Local Chat Suite.
 *
 * Local Chat is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Meat is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with the Local Chat Suite.  If not, see
 * <http://www.gnu.org/licenses/>.
 */

#include <_p_curses>
#include <iostream>

#include <vector>
#include <signal.h>

#ifndef _CPPCURSES_H
#define _CPPCURSES_H

namespace curs {

  /***************************************************************************
   */

  class terminal {
  public:
    static void initialize();

    static void restore() noexcept;

    static std::string type();

    static void clear();

    static void update();

    static void cbreak(bool value);

    static void raw(bool value);

    static void echo(bool value);

    static int halfdelay(int time) { return ::halfdelay(time); }

    static void cursor(bool value);

    static int getch() { return ::getch(); }
  };

  /***************************************************************************
   * Curses Window Stream Buffer
   *  This create a stream buffer that writes to a curses window.
   */

  class windowbuf : public std::streambuf {
  public:
    windowbuf(WINDOW *win, bool free_window = false, size_t buffer = 2048);
    windowbuf(const windowbuf &other) = delete;
    virtual ~windowbuf() noexcept;

    WINDOW *window() const { return _window; };

  protected:
    virtual int_type overflow(int_type ch);
    virtual int sync();

  private:
    WINDOW *_window;
    bool _free_window;
    bool _use_stdscr;

    std::vector<char> _obuf;

    bool oflush();
  };

  /***************************************************************************
   * Curses Pad Stream Buffer
   *  This create a stream buffer that writes to a curses window.
   */

  class padbuf : public std::streambuf {
  public:
    padbuf(int width, int height, size_t buffer = 2048);
    virtual ~padbuf() noexcept;

    WINDOW *window() const { return _pad; };

  protected:
    virtual int_type overflow(int_type ch);
    virtual int sync();

  private:
    WINDOW *_pad;

    int x, y;
    int dest_x, dest_y, dest_width, dest_height;

    std::vector<char> _obuf;

    bool oflush();
  };

  /***************************************************************************
   */

  class window : public std::ostream {
  public:
    window();
    window(int x, int y, int width, int height);
    window(const window &parent, int x, int y, int width, int height);
    window(const window &other) = delete;
    virtual ~window() noexcept;

    void cursor(int &x, int &y) const;
    void size(int &width, int &height) const;
    void position(int &x, int &y) const;
    int width() const;
    int height() const;
    int x() const;
    int y() const;

    operator WINDOW *() const { return _windowbuf.window(); }

    friend std::ostream &clear(std::ostream &os);
    friend std::ostream &erase(std::ostream &os);
    friend std::ostream &clrtobot(std::ostream &os);
    friend std::ostream &clrtoeol(std::ostream &os);
    friend std::ostream &touch(std::ostream &os);
    friend std::ostream &noutrefresh(std::ostream &os);
    friend std::ostream &resize(std::ostream &os);
    friend class keypad;
    friend class nodelay;
    friend class scrollok;
    friend class leaveok;
    friend class attron;
    friend class attroff;
    friend class attrset;
    friend class bkgd;
    friend class cursor;
    friend class hline;
    friend class vline;
    friend class box;
    friend class border;
    friend class resize;
    friend class move;

  private:
    window *_parent;
    windowbuf _windowbuf;
  };

  /***************************************************************************
   * Window IO Manipulators
   */

  class osmanip {
  public:
    virtual std::ostream &operator()(std::ostream &os) const = 0;
  };

  std::ostream &clear(std::ostream &os);
  std::ostream &erase(std::ostream &os);
  std::ostream &clrtobot(std::ostream &os);
  std::ostream &clrtoeol(std::ostream &os);
  std::ostream &touch(std::ostream &os);
  std::ostream &noutrefresh(std::ostream &os);

  class keypad : public osmanip {
  public:
    explicit keypad(bool use) : _use(use) {}
    virtual std::ostream &operator()(std::ostream &os) const;
  private:
    bool _use;
  };

  class nodelay : public osmanip {
  public:
    explicit nodelay(bool value) : _value(value) {}
    virtual std::ostream &operator()(std::ostream &os) const;
  private:
    bool _value;
  };

  class scrollok : public osmanip {
  public:
    explicit scrollok(bool value) : _value(value) {}
    virtual std::ostream &operator()(std::ostream &os) const;
  private:
    bool _value;
  };

  class leaveok : public osmanip {
  public:
    explicit leaveok(bool value) : _value(value) {}
    virtual std::ostream &operator()(std::ostream &os) const;
  private:
    bool _value;
  };

  class attron : public osmanip {
  public:
    explicit attron(int attr) : _attr(attr) {}
    virtual std::ostream &operator()(std::ostream &os) const;
  private:
    int _attr;
  };

  class attroff : public osmanip {
  public:
    explicit attroff(int attr) : _attr(attr) {}
    virtual std::ostream &operator()(std::ostream &os) const;
  private:
    int _attr;
  };

  class attrset : public osmanip {
  public:
    explicit attrset(int attr) : _attr(attr) {}
    virtual std::ostream &operator()(std::ostream &os) const;
  private:
    int _attr;
  };

  class bkgd : public osmanip {
  public:
    explicit bkgd(wchar_t ch) : _attr(0), _character(ch) {}
    explicit bkgd(wchar_t ch, attr_t attr) : _attr(attr), _character(ch) {}
    virtual std::ostream &operator()(std::ostream &os) const;
  private:
    attr_t  _attr;
    wchar_t _character;
  };

  class cursor : public osmanip {
  public:
    explicit cursor(int x, int y) : _op(POSITION), _x(x), _y(y) {}
    explicit cursor(bool show) : _op(VISIBLITY), _show(show) {}
    virtual std::ostream &operator()(std::ostream &os) const;
  private:
    enum {POSITION, VISIBLITY} _op;
    int _x, _y;
    bool _show;
  };

  class hline : public osmanip {
  public:
    explicit hline(int length, chtype character = 0)
      : _character(character), _length(length) {}
    virtual std::ostream &operator()(std::ostream &os) const;
  private:
    chtype _character;
    int _length;
  };

  class vline : public osmanip {
  public:
    explicit vline(int length, chtype character = 0)
      : _character(character), _length(length) {}
    virtual std::ostream &operator()(std::ostream &os) const;
  private:
    chtype _character;
    int _length;
  };

  class box : public osmanip {
  public:
    explicit box(chtype horch = 0, chtype verch = 0)
      : _horch(horch), _verch(verch) {}
    virtual std::ostream &operator()(std::ostream &os) const;
  private:
    chtype _horch, _verch;
  };

  class border : public osmanip {
  public:
    explicit border(chtype ls = 0, chtype rs = 0, chtype ts = 0, chtype bs = 0,
                    chtype tl = 0, chtype tr = 0, chtype bl = 0, chtype br = 0)
      : _ls(ls), _rs(rs), _ts(ts), _bs(bs), _tl(tl), _tr(tr), _bl(bl),
        _br(br) {}
    virtual std::ostream &operator()(std::ostream &os) const;
  private:
    chtype _ls, _rs, _ts, _bs, _tl, _tr, _bl, _br;
  };

  class resize : public osmanip {
  public:
    explicit resize(int width, int height)
      : _width(width), _height(height) {}
    virtual std::ostream &operator()(std::ostream &os) const;
  private:
    int _width, _height;
  };

  class move : public osmanip {
  public:
    explicit move(int x, int y) : _x(x), _y(y) {}
    virtual std::ostream &operator()(std::ostream &os) const;
  private:
    int _x, _y;
  };

  /***************************************************************************
   */

  class palette {
  public:
    static const unsigned int BLACK   = COLOR_BLACK;
    static const unsigned int RED     = COLOR_RED;
    static const unsigned int GREEN   = COLOR_GREEN;
    static const unsigned int YELLOW  = COLOR_YELLOW;
    static const unsigned int BLUE    = COLOR_BLUE;
    static const unsigned int MAGENTA = COLOR_MAGENTA;
    static const unsigned int CYAN    = COLOR_CYAN;
    static const unsigned int WHITE   = COLOR_WHITE;

    static bool has_colors();
    static bool can_change_color();
    static inline int start() { return start_color(); }

    static inline int colors() { return COLORS; }
    static inline int pairs() { return COLOR_PAIRS; }

    static inline int pair(int index, int fg, int bg) {
      return init_pair(index, fg, bg);
    }
    static inline int pair(int index) { return COLOR_PAIR(index); }

    static inline int color(int index, int r, int g, int b) {
      return init_color(index, r, g, b);
    }
  };

  namespace events {
    /** Process one event.
     */
    void process();

    /** Main event loop.
     */
    void main();

    /** Shuts down the main event loop.
     */
    void quit();
  }

  class resize_event_handler {
  public:
    resize_event_handler();
    virtual ~resize_event_handler() noexcept;

  protected:
    virtual void resize_event();

  private:
    static resize_event_handler *_handler;

    sighandler_t _orig_handler;

    static void _callback(int signal);
  };

  class keyboard_event_handler {
  public:
    keyboard_event_handler();

    void focus();
    bool has_focus() const;

    friend void events::main();
    friend void events::process();

  protected:

    virtual void key_event(int ch) = 0;
    virtual void lose_focus() {}
    virtual void gain_focus() {}
  };

  class mouse_event_handler {
  public:
    mouse_event_handler();
    virtual ~mouse_event_handler() noexcept;

    friend void events::main();
    friend void events::process();

  protected:

    virtual void event(short id, int x, int y, mmask_t buttons) = 0;
  };
}

std::ostream & operator <<(std::ostream &ios, const curs::osmanip &manip);

#endif /* _CPPCURSES_H */
